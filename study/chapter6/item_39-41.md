# 아이템 39 | 명명 패턴보다 애너테이션을 사용하라
## 명명 패턴의 단점
1. 오타가 나면 안 된다.
2. 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다.
3. 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다.

### 아이템 62 | 다른 타입이 적절하다면 문자열 사용을 피하라
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
- 문자열은 열거 타입을 대신하기에 적합하지 않다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
    - ```
      String compoundKey = className + "#" + i.next();
      ```
    - 두 요소를 구분해주는 문자 #이 두 요소 중 하나에서 쓰였다면 혼란스러운 결과를 초래한다.
    - 차라리 전용 클래스를 새로 만드는 편이 나으며, 이런 클래스는 보통 private 정적 멤버 클래스로 선언한다.(아이템 24)
- 문자열은 권한을 표현하기에 적합하지 않다.

### 메타 애너테이션(meta-annotation)
> 애너테이션 선언에 다는 애너테이션

- @Retension : 애너테이션의 유지 정책을 지정하는 데 사용
  - RententionPolicy.SOURCE : 컴파일 시에만 유효하며, 클래스 파일에는 포함되지 않는다.
    - @Override
      - 메서드가 슈퍼클래스의 메서드를 오버라이드하고 있는지 확인하는 데 사용된다.
      - 컴파일러가 코드를 검사할 때만 필요하고, 런타임에는 사용되지 않는다.
  - RententionPolicy.CLASS : 클래스 파일에 저장되지만 런타임에는 사용할 수 없다.
    - JavaBeans 패턴의 'get', 'set' 메서드
  - RententionPolicy.RUNTIME
    - @Test
      - JUnit과 같은 테스트 프레임워크는 런타임에 테스트 케이스를 찾고 실행.
      - 테스트 메서드를 표시하고, 리플렉션을 사용하여 런타임에 테스트를 찾고 실행한다.
- @Target : 다른 커스텀 애너테이션을 정의할 때 사용되며, 해당 애너테이션을 적용할 수 있는 대상(Element)을 지정하는 역할을 한다.
  - ElementType.TYPE : 클래스, 인터페이스, 열거형 등의 선언 요소
  - ElementType.FIELD
  - ElementType.METHOD
  - ElementType.PARAMETER
  - ElementType.CONSTRUCTOR
  - ElementType.LOCAL_VARIABLE
  - ElementType.ANNOTATION_TYPE
  - ElementType.PACKAGE
- @Repeatable : 커스텀 애너테이션을 반복해서 사용할 수 있도록 해주는 애너테이션
  - 반복 가능한 애너테이션을 정의하고 컨테이너 애너테이션을 만든다.
  - 컨테이너 애너테이션은 @Repeatable 애너테이션을 사용하고, 반복 가능한 애너테이션의 배열을 요소로 가지도록 정의한다.
  - 컴파일러는 반복 가능한 애너테이션을 컨테이너 애너테이션으로 래핑하고 코드를 생성한다.
  - 런타임에 애너테이션 정보를 검색할 때 반복 가능한 애너테이션을 읽거나 컨테이너 애너테이션을 통해 모든 애너테이션 정보를 얻을 수 있다.

### 리플렉션(Reflection)
- 프로그램이 자신의 구조를 검사하고 수정하는 데 사용되는 메커니즘.
- 자바에서 리플렉션은 클래스, 메서드, 필드, 생성자 등과 같은 객체와 그 객체의 속성(메타데이터)을 동적으로 조사하고 조작할 수 있는 기능을 제공한다.
```java
try {
    // 리플렉션을 사용하여 메서드를 호출
    method.invoke(targetObject);
} catch (InvocationTargetException ex) {
    // InvocationTargetException으로 래핑된 예외를 얻음
    Throwable originalException = ex.getCause();
    
    // 원본 예외를 처리
    if (originalException instanceof SomeException) {
        // 예외 처리 로직
    }
}
```

# 아이템 40 | @Override 애너테이션을 일관되게 사용하라
### @Override : 컴파일러에게 메서드가 슈퍼클래스 또는 인터페이스의 메서드를 오버라이드하려는 것임을 알려준다.
- 컴파일러 검사: 메서드에 `@Override` 애너테이션을 사용하면 컴파일러가 해당 메서드가 슈퍼클래스나 인터페이스의 메서드를 오버라이드하려는 것임을 확인하고, 오버라이드와 관련된 오류를 미리 감지할 수 있다. 이를 통해 오버라이드한 메서드가 실제로 상위 클래스의 메서드와 시그니처가 일치하는지 확인할 수 있다.
- 코드 가독성: `@Override` 애너테이션을 사용하면 코드를 읽는 사람에게 해당 메서드가 오버라이드되는 것임을 명확하게 표시할 수 있다.

# 아이템 41 | 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라
## 마커 인터페이스(marker interface)
> 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스

### 마커 인터페이스가 마커 애너테이션보다 나은 점
- 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 애너테이션은 그렇지 않다.
  - 마커 인터페이스는 어엿한 타입이기 때문에, 마커 애너테이션을 사용했다면 런타임에야 발견될 오류를 컴파일타임에 잡을 수 있다.
- 적용 대상을 더 정밀하게 지정할 수 있다.
  - 적용 대상(@Target)을 ElementType.TYPE으로 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거 타입, 애너테이션)에 달 수 있다.
  - 마커 인터페이스로 정의하면 마킹하고 싶은 클래스에서만 그 인터페이스를 구현(인터페이스라면 확장)하면 된다.

### 마커 애너테이션이 마커 인터페이스보다 나은 점
- 거대한 애너테이션 시스템의 지원을 받을 수 있다.
- 애너테이션을 적극 활용하는 프레임워크에서는 마커 애너테이션을 쓰는 쪽이 일관성을 지키는 데 유리하다.

### 언제 어떤 방식을 사용해야할까?
- 클래스와 인터페이스 외의 프로그램 요소(모듈, 패키지, 필드, 지역변수 등)에 마킹해야 할 때 애너테이션을 쓸 수 밖에 없다.
  - 클랫그와 인터페이스만이 인터페이스를 구현하거나 확장할 수 있기 때문.
- 마커를 클래스나 인터페이스에 적용해야 한다면
  - 마킹이 된 객체를 매개변수로 받는 메서드를 작성해야한다면 마커 인터페이스를 해당 메서드의 매개변수 타입으로 사용하여 컴파일타임에 오류를 잡을 수 있다.
  - 이러한 메서드를 작성할 일이 절대 없다고 확신한다면 마커 애너테이션이 나은 선택일 수 있다.
- 애너테이션을 활발히 활용하는 프레임워크에서 사용하려는 마커라면 마커 애너테이션을 사용하는 편이 좋을 것이다.