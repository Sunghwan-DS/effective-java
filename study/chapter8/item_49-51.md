# 아이템 49 | 매개변수가 유효한지 검사하라
### 매개변수 검사를 제대로 하지 못했을 경우
- 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 때
- 메서드가 잘 수행되지만 잘못된 결과를 반환할 때
- 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어 놓아서 미래의 알수 없는 시점에 이 메서드와는 관계 없는 오류를 만들 때

### 매개변수 검사
- 실패 원자성 - 아이템 76 | 가능한 한 실패 원자적으로 만들라
  - 호출된 메서드가 실패 하더라도 호출된 메서드의 객체는 메서드 호출 전 상태를 유지해야 한다.
- public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다 - 아이템 74 | 메서드가 던지는 모든 예외를 문서화하라
- 보통은 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException 중 하나가 될 것이다 - 아이템 72 | 표준 예외를 사용하라

#### 클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.
BigInteger의 클래스 수준 주석 일부
```
* {@code NullPointerException} when passed
* a null object reference for any input parameter.
```
BigInteger 클래스의 모든 클래스 메서드 중 어떤 매개변수에 null 객체 참조를 전달하면 예외가 발생

### 자바의 null 검사 기능
- 자바 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.
- 자바 9에서는 Objects에 범위 검사 기능도 더해졌다.
  - checkFromIndexSize
    - 시작 인덱스와 크기가 주어진 길이의 범위 내에 있는지 확인
  - checkFromToIndex
    - 시작 인덱스와 끝 인덱스가 주어진 길이의 범위 내에 있는지 확인
  - checkIndex
    - 주어진 인덱스가 주어진 길이의 범위 내에 있는지 확인
    - 이 메서드만 주어진 인덱스 포함이라 index >= length
      - 단힌 범위를 다루지 못한다
- public 이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.
  - 실패하면 AssertionError를 던진다
  - 런타임에 아무런 효과도, 아무런 성능 저하도 없다
    - java를 실행할 때 명령줄에서 -ea 혹은 --enableassertions 플래그를 설정하면 런타임에 영향을 준다

코드 20-1 골격 구현을 사용해 완성한 구체 클래스
```java
static List<Integer> intArrayAsList(int[] a) {
    Objects requireNonNull(a);
    
    return new AbstractList<>() {
        ...
    }
}
```
requireNonNull 을 생략했다면 클라이언트가 생성된 List 인스턴스를 사용하려할 때 비로서 NullPointerException이 발생한다.

#### 메서드 몸체 실행 전에 매개변수 유효성을 검사하지 않아도 되는 경우
- 유효성 검사 비용이 지나치게 높거나 실용적이지 않은 경우
- 계산 과정에서 암묵적으로 검사가 수행되는 경우

# 아이템 50 | 적시에 방어적 복사본을 만들라
#### 메모리 충돌 오류
- 버퍼 오버런
  - 배열이나 버퍼의 크기를 초과하여 데이터를 쓰거나 읽는 오류
- 배열 오버런
  - 배열의 인덱스를 벗어나 접근하는 오류
- 와일드 포인터
  - 이미 해제된 메모리를 참조하거나 초기화되지 않은 포인터를 사용하는 오류
- 댕글링 포인터
  - 이미 해제된 메모리 주소를 가리키는 포인터를 사용하려고 할 때 발생하는 오류
- 이중 해제
  - 이미 해제된 메모리를 또 다시 해제하려고 할 때 발생하는 오류

#### 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy)해야 한다.
- 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사해야 한다. 
  - 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
- 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.
  - clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다.
  - 생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다.
- 새로운 접근자까지 갖추면 완벽한 불변으로 거듭난다.
  - 모든 필드가 객체 안에 완벽하게 캡슐화
- 인스턴스를 복사하는 데는 일반적으로 생성자나 정적 팩터리를 쓰는게 좋다.
- 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.

#### 방어적 복사를 생략해도 되는 상황
- 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때
- 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때
  - 래퍼 클래스 패턴(Wrapper Pattern)
    - 클래스에 대한 인터페이스를 호환되는 다른 인터페이스로 변환하는 패턴
    - 클라이언트는 래퍼에 넘긴 객체에 대해 여전히 직접 접근할 수 있다.
      - 래퍼의 불변식을 쉽게 파괴할 수 있지만 그 영향을 오직 클라이언트 자신만 받게 된다.
