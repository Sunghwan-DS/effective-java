# 아이템 47 | 반환 타입으로는 스트림보다 컬렉션이 낫다

### 스트림 개념 이전에 적합한 반환 타입 고르기
- for-each 문에서만 쓰이거나 반환된 원소 시퀀스가 일부 Collection 메서드를 구현할 수 없을 때 -> Iterable 인터페이스 
- 반환 원소들이 기본 타입이거나 성능에 민감한 상황 -> 배열

#### 스트림은 반복을 지원하지 않는다?
일반적인 반복문과는 다르게 데이터를 다루는 방식이라는 것을 강조하는 것 같다.

스트림은 내부적으로 반복을 수행하지만, 이를 라이브러리가 추상화하여 사용자에게 더 간결하고 표현력있게 다양한 연산을 수행할 수 있도록 제공한다.

스트림은 반복의 개념을 포함하면서도 더 높은 수준의 추상화를 제공하여 코드를 간결하게 작성하고 가독성을 높여준다고 해석해야하지 않을까?

#### 잠깐 흝고 넘어가보는 ProcessHandle
`ProcessHandle` 인터페이스는 Java 9에서 도입된 인터페이스로, 프로세스의 정보를 쿼리하고 제어하는 기능을 제공한다.

- pid()
  - 현재 프로세스의 프로세스 ID(PID)를 반환
- info()
  - 프로세스에 대한 `ProcessHandle.Info` 객체를 반환
  - 프로세스의 여러 속성 및 메타 데이터를 얻을 수 있다.
    - command()
      - Optional<String> 반환
  - `ProcessHandle` 인터페이스 안에 `Info` 인터페이스로 구현되어있다.
- children() & parent()
  - 현재 프로세스의 자식 또는 부모 프로세스에 대한 `ProcessHandle` 을 반환
- allProcesses()
  - 현재 실행 중인 모든 프로세스의 `Stream<ProcessHandle>` 을 반환
  - 코드 47-2) Stream 은 Iterable 을 확장하지 않아 for-each로 반복할 수 없다.
    - 때문에 Iterable 로 형변환하여 코드 오류를 해결

```java
for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
    // 프로세스를 처리한다.
}
```
ProcessHandle.allProcesses()는 Stream<ProcessHandle> 을 반환하는데 Stream은 한 번만 소비할 수 있는 데이터 소스로서의 역할을 가지고 있기 때문에

stream에 직접 iterator() 메서드를 호출하면 Iterator 객체를 얻을 수 없다.

Stream을 Iterable 로 변환하려면 stream::iterator 형태의 람다 표현식이나 명시적으로 stream.iterator() 와 같이 iterator() 메서드를 호출하는 방식을 사용해야 한다.

### 결론
#### 원소 시퀀스를 반환하는 메서드를 작성할 때는
- Stream 반환
- Iterable 반환
  - Collection 반환이 가능한가? (Iterable 하위 타입)
    - Yes : 시퀀스 크기가 메모리에 올려도 안전할만큼 작은가?
      - Yes : 표준 컬렉션 구현체를 반환
      - No : 전용 컬렉션을 구현
    - No : Stream과 Iterable 중 더 자연스러운 것을 반환 | 위에서 Stream 반환은 이미 구현했어야 하는게 아닐까?
