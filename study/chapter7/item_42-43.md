# 아이템 42 | 익명 클래스보다는 람다를 사용하라
### 익명 클래스(Anonymous Class)
> Java에서 클래스를 정의하면서 동시에 객체를 생성하는 방법 중 하나
> 
> 익명 클래스는 이름이 없는 클래스로, 클래스 정의와 객체 생성을 한 번에 처리할 수 있어 간결한 코드를 작성하는 데 도움이 된다.

익명 클래스의 특징
- 이름이 없다.
  - 익명 클래스는 이름을 가지지 않으며, 한 번만 사용하고 버릴 목적으로 주로 사용된다.
- 인터페이스 구현 또는 상속
  - 익명 클래스는 인터페이스를 구현하거나 클래스를 상속받을 수 있다.
- 클래스 정의와 객체 생성을 한 번에 처리
  - 익명 클래스를 정의하면서 객체를 생성하므로, 코드를 간결하게 만들 수 있다.
- 외부 변수 접근
  - 익명 클래스 내부에서 외부 변수에 접근할 때에는 해당 변수는 `final` 이거나 사실상 `final` 로 취급되어야 한다.

### 람다식(lambda expression)
> Java 8부터 도입된 함수형 프로그래밍의 핵심 요소 중 하나로, 람다식은 익명 함수를 나타내며, 함수를 변수에 할당하거나 다른 함수에 전달할 수 있도록 하는 방법을 제공한다.

람다식의 특징
- 간결한 문법
- 익명 함수
- 함수형 인터페이스와의 연관성
- 지연 실행
- 클로저 지원
- 병렬 처리와 스트림 API
- 코드 가독성 향상
- 람다 캡슐화
- 다른 함수로 전달 가능
- 재사용성

### 익명 클래스 대신 람다을 사용해야 하는 이유
- 코드 간결성
- 가독성 향상
- 함수형 프로그래밍 스타일
- 함수형 인터페이스 활용
- 코드 중복 제거
- 병렬 처리 및 스트림 API
- 자연스러운 클로저
- 테스트 용이성

익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.

### 람다 사용시 주의점
- 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략한다.
- 코드 자체로 동장이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 않는다.
- 람다를 직렬화하는 일은 극히 삼가야 한다.

# 아이템 43 | 람다보다는 메서드 참조를 사용하라
익명 클래스 대신 람다를 사용하는 이유 중 가장 큰 특징은 간결함.
람다보다도 더 간결하게 만드는 방법이 있다면?

### 메서드 참조(method reference)
> Java에서 함수형 프로그래밍을 지원하는 기능 중 하나로, 메서드를 가리키는 간결한 표현을 제공하여 코드를 더 간결하게 만들고 가독성을 향상시킨다.

메서드 참조가 유용한 경우
1. 인터페이스의 추상 메서드를 구현하기 위해 이미 존재하는 메서드를 사용할 때
2. 람다식을 더 간결하게 만들 때, 특히 메서드 참조로 인해 코드의 가독성이 향상될 때

```java
map.merge(key, 1, (count, incr) -> count + incr);

map.merge(key, 1, Integer::sum)
```

어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 하여, 이런 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.

-> 예시가 있으면 좋겠는데 특별히 생각나는 케이스가 없다..

### 메서드 참조 유형 5가지
- 정적 메서드를 가리키는 메서드 참조
  - Integer::parseInt
- 인스턴스 메서드를 참조하는 유형 두 가지
  - 수신 객체를 특정하는 한정적 인스턴스 메서드 참조
    - Instant.now()::isAfter
  - 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
    - String::toLowerCase
- 클래스 생성자를 가리키는 메서드 참조
  - TreeMap<K, V>::new
- 배열 생성자를 가리키는 메서드 참조
  - int[]::new

### 람다로는 불가능하나 메서드 참조로 가능한 유일한 예 | 제네릭 함수 타입 구현
함수형 인터페이스의 추상 메서드가 제네릭일 수 있듯이 함수 타입도 제네릭일 수 있다.

```java
interface G1 {
    <E extends Exception> Object m() throws E;
}
interface G2 {
    <F extends Exception> String m() thorws Exception;
}
interface G extends G1, G2 {}
```

이때 함수형 인터페이스 G를 함수 타입으로 표현하면 다음과 같다.

```java
<F extends Exception> () -> String throws F
```

제네릭 람다식이라는 문법이 존재하지 않아 위와 같은 함수형 인터페이스를 위한 제네릭 함수 타입은 메서드 참조 표현식으로만 구현할 수 있다.