# 아이템 44 | 표준 함수형 인터페이스를 사용하라
### 템플릿 메서드 패턴
객체지향 프로그래밍에서 사용되는 디자인 패턴 중 하나.

알고리즘의 구조를 정의하고 구체적인 단계를 서브클래스에서 구현할 수 있게 하는 패턴.

템플릿 메서드를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것이다.

LinkedHashMap을 오늘날 다시 구현한다면 함수 객체를 받는 정적 팩터리나 생성자를 제공했을 것이다.

### 정적 팩터리(static factory method)
겍체를 생성하는 디자인 패턴 중 하나로, 클래스의 인스턴스를 생성하는 메서드를 정적(static)으로 제공하는 것을 말한다.

#### 정적 팩터리의 특징과 장점
- 명명 규칙
- 재사용성
- 유연성
- 불변 객체
- 싱글톤 패턴 적용

예를 들어. 'java.util.Collections' 클래스는 정적 팩터리 메서드를 제공한다.

'Collections' 클래스에서 객체를 생성할 때 'emptyList()', 'singletonList()', 'unmodifiableList()' 등의 정적 팩터리 메서드를 사용할 수 있다.

```java
LinkedHashMap<K, V> linkedHashMap = new LinkedHashMap<>(K, V, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > 100;
    }
};

LinkedHashMap<K, V> linkedHashMap = new LinkedHashMap<>(K, V, true,
    (eldest) -> size() > 100
);
```

생성자에 넘기는 함수 객체는 이 맵의 인스턴스 메서드가 아니다. 팩터리나 생성자를 호출할 때는 맵의 인스턴스가 존재하지 않기 때문이다.

```java
@FunctionalInterface interface EldestEntryRemovalFuncion<K, V> {
    boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
}
```

필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인테페이스를 활용하라.

표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.

### 표준 함수형 인터페이스

- UnaryOperator
  - 하나의 입력값을 받아 동일한 타입의 출력값을 반환하는 연산을 수행하는 함수
- BinaryOperator
  - 두 개의 동일한 타입의 입력값을 받아서 하나의 동일한 타입의 출력값을 반환하는 연산을 수행하는 함수
- Predicate
  - 하나의 입력값을 받아서 논리적인 조건을 검사하여 'true' 또는 'false'를 반환하는 함수
  - 컬렉션의 요소를 조건에 따라 필터링할 때 유용하게 사용
- Function
  - 하나의 입력값을 받아 다른 타입의 결과를 반환하는 함수
  - 데이터 변환이나 매핑 작업 등에서 사용
    - 스트림 API에서 'map' 연산에서도 'Function' 인터페이스를 사용하여 각 요소를 변환하는 데 활용될 수 있다
- Supplier
  - 매개변수 없이 값을 제공하는 함수
  - 어떤 값을 생성해야 하는데 그 값이 외부에서 주어지지 않고 내부에서 생성되어야 할 때 사용
    - 초기화 작업에서 랜덤한 값을 생성하거나, 지연 초기화(Lazy Initialization)에서 처음 요청 시에 값을 생성하는 데 활용될 수 있다
- Consumer
  - 하나의 입력값을 받아서 아무런 결과도 반환하지 않는 함수
  - 어떤 동작이나 작업을 각 요소에 적용할 때 사용
    - 리스트의 각 요소를 처리하거나, 파일이나 네트워크 연결을 닫는 등의 작업을 수행할 때 활용될 수 있다

### 기본 인터페이스
기본 타입인 int, long, double용으로 각 3개씩 변형이 생겨난다.

(int, long, double) - (기본 타입)

(기본 타입) + 표준 함수형 인터페이스
(기본 타입)To(기본 타입)Function
To(기본 타입)Function

#### 인수를 2개씩 받는 변형
Bi + 표준 함수형 인터페이스

BooleanSupplier

표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.
##### 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자.
"박싱된 기본 타입 대신 기본 타입을 사용하라" - 아이템 61

Comparator 가 독자적인 인터페이스로 살아남아야 하는 이유
1. API에서 굉장히 자주 사용되는데, 지금의 이름이 그 용도를 아주 훌륭히 설명해준다.
2. 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있다.
3. 비교자들은 변환하고 조합해주는 유용한 디폴트 메서드들을 듬뿍 담고 있다.

2, 3 번은 ToIntBiFunction<T, U> 에도 구현하면 안되는 것일까?

아무튼 위 3가지 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 하는 건 아닌지 고민하자.

### @FunctionalInterface
함수형 인터페이스는 딱 하나의 추상 메서드만을 가지는 인터페이스이며, 이를 통해 람다 표현식에서 메서드 참조를 사용하여 함수를 전달할 수 있다.

'@FunctionalInterface' 애너테이션을 사용하면 해당 인터페이스가 함수형 인터페이스임을 강제할 수 있고, 컴파일러는 이 규칙을 지키지 않으면 오류를 발생시킨다.

1. 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
3. 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.

##### 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.

# 아이템 45 | 스트림은 주의해서 사용하라
- 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
- 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.

스트림의 원소들은 어디로부터든 올 수 있으며, 대표적으로는 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수 생성기, 혹은 다른 스트림이 있다.

스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값이다.

### 스트림의 특징
- 스트림 파이프 라인은 소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다. 
- 스트림 파이프 라인은 지연 평가(lazy evaluation)된다.
- 스트림 API는 메서드 연쇄를 지원하는 플루언트 API(fluent API)다.
- 기본적으로 스트림 파이프라인은 순차적으로 수행된다.
- 스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.
- char 값들을 처리할 때는 스트림을 삼가는 편이 낫다.

### 스트림을 적용하기 좋은 후보
- 원소들의 시퀀스를 일관되게 변환한다.
- 원소들의 시퀀스를 필터링한다.
- 원소들의 시퀀스를 하나의 연산을 사용해 결합한다(더하기, 연결하기, 최솟값 구하기 등).
- 원소들의 시퀀스를 컬렉션에 모은다(아마도 공통된 속성을 기준으로 묶어가며).
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

# 아이템 46 | 스트림에서는 부작용 없는 함수를 사용하라
#### 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다.
이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.
> 순수 함수란 오직 입력만이 결과에 영향을 주는 함수

스트림 연산에 건네는 함수 객체는 모두 부작용(side effect)이 없어야 한다.

##### forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자.

#### 축소 전략(reduction strategy)
프로그래밍 언어에서 표현식이 값을 평가하는 방식을 나타내는 개념.

축소 전략은 언어나 컴파일러에서 사용되는 방법으로, 특정 표현식이 값을 어떻게 계산할지에 대한 규칙을 의미

### Collectors 의 나머지 36개 메서드
- toMap(keyMapper, valueMapper)
  - 스트림 원소를 키에 매핑하는 함수와 값에 매핑하는 함수를 인수로 받는다
  - 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적합
  - toConcurrentMap
    - 병렬 실행된 후 결과로 ConcurrentHashMap 인스턴스를 생성한다
- toMap(keyMapper, valueMapperm, BinaryOperator mergeFunction)
  - 인수 3개를 받는 toMap은 어떤 키와 그 키에 연관된 원소들 중 하나를 골라 연관 짓는 맵을 만들 때 유용하다
  - 충돌이 나면 마지막 값을 취하는(last-write-wins) 수집기를 만들 때도 유용하다
- toMap(keyMapper, valueMapperm, BinaryOperator mergeFunction, Supplier mapFactory)
  - EnumMap 이나 TreeMap 처럼 원하는 특정 맵 구현체를 직접 지정할 수 있다.
- groupingBy(classifier)
  - 입력으로 분류 함수(classifier)를 받고 출력으로는 원소들을 카테고리별로 모아 놓은 맵을 담은 수집기를 반환한다.
- groupingBy(classifier, downstream)
  - 반환하는 수집기가 리스트 외의 값을 갖는 맵을 생성하게 하려면, 분류 함수와 함께 다운스트림(downstream) 수집기도 명시해야 한다.
    - 다운 스트림 : 스트림 파이프라인에서 중간 연산과 최종 연산 사이의 관계를 나타내는 개념
- groupingBy(classifier, mapFactory, downstream)
  - 다운스트림 수집기에 더해 맵 팩터리도 지정할 수 있게 해준다.
  - 점층적 인수 목록 패턴에 어긋난다.
    - 객체의 생성자에 다양한 수의 매개변수를 갖는 오버로딩된 버전들을 계속해서 추가하는 디자인 패턴
- partitioningBy(predicate)
  - 분류 함수 자리에 predicate를 받고 키가 Boolean인 맵을 반환